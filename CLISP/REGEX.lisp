;---------------------------------------------------parallelize functions----------------------------------------------------
(defun deltil(exp)
    (cond
        ((null exp) nil)
        ((eq '\| (car exp)) (cdr exp))
        (T (deltil (cdr exp)))
    )
)
(defun gettil(exp)
    (cond
        ((null exp) nil)
        ((eq '\| (car exp)) nil)
        (T (cons (car exp) (gettil (cdr exp))))
    )
)
(defun paral (exp)
    (cond
        ((null exp) nil)
        (T (cons (gettil exp) (paral (deltil exp))))
    )
)
;----------------------------------------------------automatize functions------------------------------------------------------
(defun makeauto(node1 symbol node2)
    (cond
        ((eq nil node2) (list node1 symbol))
        (T (list node1 symbol node2))
    )
)
(defun iteration (iter nodenum val)
    (cond
        ((null iter) (list (makeauto nodenum val (+ 1 nodenum))))
        ((eq '+ iter) (append (list (makeauto nodenum val (+ 1 nodenum))) (list (makeauto (+ 1 nodenum) val (+ 1 nodenum)))))
        ((eq '* iter) (append (list (makeauto nodenum 'eps (+ 1 nodenum))) (list (makeauto (+ 1 nodenum) val (+ 1 nodenum)))))
        (T nil)
    )
)
(defun ifchar(exp nodenum)
    (cond
        ((null exp)nil)
        ((characterp (cadr exp)) (append (list (makeauto nodenum (car exp) (+ 1 nodenum))) (ifchar (cdr exp) (+ 1 nodenum))))
        (T (append (iteration (cadr exp) nodenum (car exp)) (ifchar (cddr exp) (+ 1 nodenum))))
    )
)
(defun ifcharfirst(exp nodenum)
    (cond
        ((null exp)nil)
        ((null (cdr exp)) (list (makeauto '0 (car exp) (+ 1 nodenum))))
        ((characterp (cadr exp)) (append (list (makeauto '0 (car exp) (+ 1 nodenum))) (ifchar (cdr exp) (+ 1 nodenum))))
        (T (append (iteration (cadr exp) nodenum (car exp)) (ifchar (cddr exp) (+ 1 nodenum))))
    )
)
(defun start (exp nodenum)
    (cond
        ((null exp) nil)
        (T (append (ifcharfirst (car exp) nodenum) (start (cdr exp) (+ 100 nodenum))))
    )
)
;---------------------------------------------------end-combining functions----------------------------------------------------------
(defun check-end(x auto)
    (cond
        ((null auto) T)
        ((eq (+ 1 x) (caddr (car auto))) nil)
        (T (check-end x (cdr auto)))
    )
)
(defun get-ends (auto)
    (cond
        ((null auto) nil)
        ((check-end (caddr (car auto)) auto) (cons (caddr (car auto)) (get-ends (cdr auto))))
        (T (get-ends (cdr auto)))
    )
)

(defun combine-last(auto) (CL auto (get-ends auto)))
(defun CL(auto lastnodes)
    (cond
        ((null auto) nil)
        ((subsetp (list (caddr (car auto))) lastnodes) (append (list (makeauto (caar auto) (cadr (car auto)) 'F)) (CL (cdr auto) lastnodes)))
        (T (append (list (car auto)) (CL (cdr auto) lastnodes)))
    )
)
;--------------------------------------------------determinating functions--------------------------------------------------------
(defun search-set (node val auto)(append (list node val) (__search-set__ node val auto)))
(defun __search-set__ (node val auto)
    (cond
        ((null auto) nil)
        ((and (eq node (caar auto)) (eq val (cadr (car auto)))) (cons (caddr (car auto)) (__search-set__ node val (cdr auto))))
        (T (__search-set__ node val (cdr auto)))
    )
)
(defun get-deltas (auto)
    (cond
        ((null auto) nil)
        (T (append (list (search-set (caar auto) (cadr (car auto)) auto)) (get-deltas (cdr auto))))
    )
)
(defun more2 (deltas)
    (cond
        ((null deltas) nil)
        ((null (cdddar deltas)) (more2 (cdr deltas)))
        (T (append (list (car deltas)) (more2 (cdr deltas))))
    )
)
(defun search-by-delta (node delta auto)(cond ((null (SBD delta auto)) nil) (T (list (append (list node) (SBD delta auto))))))
(defun SBD (delta auto)
    (cond
        ((null auto) nil)
        ((eq delta (caar auto)) (cdar auto))
        (T (SBD delta (cdr auto)))
    )
)
(defun make-fnodes (delta auto node) (append (list (makeauto (car delta) (cadr delta) node)) (make-nodes delta auto node)))
(defun make-nodes (delta auto node)
    (cond
        ((null auto) nil)
        (T (append (search-by-delta node (car delta) auto)(make-nodes (cdr delta) (cdr auto) node)))
    )
)
(defun make-new-deltas (auto) (MND auto (more2 (get-deltas auto)) (random 1000)))
(defun MND (auto m2 node)
    (cond
        ((null m2) nil)
        (T (append (make-fnodes (car m2) auto node) (MND auto (cdr m2) (random 1000))))
    )
)
(defun search-by-ending-node (node auto)
    (cond
        ((null auto) nil)
        ((eq node (caar auto)) (append (list (car auto)) (search-by-ending-node node (cdr auto))))
        (T (search-by-ending-node node (cdr auto)))
    )
)
(defun determinate (automaton) (append (make-new-deltas automaton) (DTM automaton (make-new-deltas automaton))))
(defun DTM (auto deltas)
    (cond
        ((null deltas) nil)
        (T (append (search-by-ending-node (car (cddar deltas)) auto) (DTM (cdr auto) (cdr deltas))))
    )
)
;-----------------------------------------------------------main------------------------------------------------------------------
(defun regex(expression)
    (combine-last (start (paral expression) 0))
)

; (print (regex '(#\a + #\b \| #\a #\b * #\a)))
; (print '=>)
; (print (determinate (regex '(#\a + #\b \| #\a #\b * #\a))))
; (terpri)
; (print (regex '(#\a #\b + #\a * #\b \| #\a #\b + #\a + #\b + #\b)))
; (print '=>)
; (print (determinate (regex '(#\a #\b + #\a * #\b \| #\a #\b + #\a + #\b + #\b))))
(print (regex '(#\a #\b * #\b \| #\a)))
(print '=>)
(print (determinate (regex '(#\a #\b \| #\a))))
